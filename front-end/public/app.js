var quotesFile = JSON.stringify([
  {"quote": "Искреннее сердце — это драгоценность, которую никогда никуда не спрячешь.", "author": "Ходзе Сигэтоки (1198–1261) — монах, писатель"},
  {"quote": "Глубоко постигни этот мир снов, который проходит в мгновение ока.", "author": "Ходзе Сигэтоки (1198–1261) — монах, писатель"},
  {"quote": "Если ты раздумываешь, делать это или не делать, то, как правило, бывает лучше этого не делать.", "author": "Кэнко Хоси (Урабэ Канэеси) (1283–1350) — писатель"},
  {"quote": "В высшей степени достойно сожаления, если самурай упускает момент, когда ему следует умереть.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Людей с острым умом следует искать среди тех, кто склонен думать.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Самурай должен умиротворять свое сердце и смотреть вглубь других. Вот высшее из всех боевых искусств.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Даже если у человека нет особых талантов, но он упорно овладевает знанием, он не опозорится перед другими.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Каждого человека следует использовать в соответствии с его способностями.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Природа человека устроена так, что учиться добру очень тяжело, а склоняться ко злу — легко, поэтому каждый постепенно становится похожим на тех, с кем он знаком.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Нет ничего более постыдного для человека, чем выходить из себя.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Несомненное достоинство — не стыдиться исправлять собственные ошибки. Первый же недостаток — вбить что-нибудь себе в голову, хорошее или плохое, и упрямо стоять на своем.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "Даже если в ходе сражения ты видишь, что не сможешь победить, укрепи свое сердце и будь уверен, что никто не сможет превзойти тебя в стойкости.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "В этом изменчивом мире следует идти по пути самодисциплины.", "author": "Сиба Есимаса (1350–1419) — выдающийся администратор, полководец, поэт"},
  {"quote": "По-настоящему прозорливый человек всегда увидит и начало, и конец, и не станет пренебрегать даже мельчайшими деталями.", "author": "Такэда Сингэн (1521–1573) — великий полководец"},
  {"quote": "Если люди дальновидны, находчивы и умеют оценить ситуацию, то какие бы трудности не стали перед ними, их слава будет жить в последующих поколениях.", "author": "Такэда Сингэн (1521–1573) — великий полководец"},
  {"quote": "Учение для человека — все равно что ветви и листья для дерева. Без него он просто не сможет жить.", "author": "Такэда Сингэн (1521–1573) — великий полководец"},
  {"quote": "Пусть твои воины не поносят врага. Древняя пословица гласит: «Разбуди пчелу, и она набросится на тебя с яростью дракона».", "author": "Такэда Нобусигэ (1525–1561) — воин"},
  {"quote": "Никогда и ни при каких обстоятельствах не лги.", "author": "Такэда Нобусигэ (1525–1561) — воин"},
  {"quote": "Не пренебрегай упреками в свою сторону.", "author": "Такэда Нобусигэ (1525–1561) — воин"},
  {"quote": "Не сражайся за все подряд.", "author": "Такэда Нобусигэ (1525–1561) — воин"},
  {"quote": "Никогда не показывай собственной слабости, даже в присутствии любящих тебя родственников и вассалов.", "author": "Такэда Нобусигэ (1525–1561) — воин"},
  {"quote": "Не теряй себя из-за одной ошибки. Главное — не утратить впоследствии присутствия духа.", "author": "Такэда Нобусигэ (1525–1561) — воин"},
  {"quote": "Даже если ты с кем-нибудь очень близок, хорошо подумай, прежде чем обратиться к нему с просьбой.", "author": "Такэда Нобусигэ (1525–1561) — воин"},
  {"quote": "Знатен человек или низок по происхождению, но если он хотя бы раз не поставил на карту свою жизнь, у него есть повод устыдиться.", "author": "Набэсима Наосигэ (1538–1618) — самурай"},
  {"quote": "Ум — это цветок проницательности. Но есть много примеров, когда цветы цветут, но не плодоносят.", "author": "Набэсима Наосигэ (1538–1618) — самурай"},
  {"quote": "Во всех делах в первую очередь думай о человеке.", "author": "Набэсима Наосигэ (1538–1618) — самурай"},
  {"quote": "Во всем надлежит действовать терпеливо.", "author": "Набэсима Наосигэ (1538–1618) — самурай"},
  {"quote": "Если дела делаются с неохотой, семь из десяти окончатся неудачей.", "author": "Набэсима Наосигэ (1538–1618) — самурай"},
  {"quote": "В сражении следует быть жестоким и безрассудным. Но забудь об этом в повседневной жизни.", "author": "Набэсима Наосигэ (1538–1618) — самурай"},
  {"quote": "Если будешь отдавать свое сердце утонченному и изящному, то уподобишься женщине. Рожденный в доме самурая должен думать только о том, как взять короткий и длинный мечи и умереть.", "author": "Като Киемаса (1562–1611) — выдающийся полководец"},
  {"quote": "Самурай, увлекающийся танцами, кои не входят в число боевых искусств, должен быть приговорен к сэппуку.", "author": "Като Киемаса (1562–1611) — выдающийся полководец"},
  {"quote": "Самурай должен иметь доспехи, соответствующие его положению, платить своим слугам, а остальные деньги использовать для военных нужд.", "author": "Като Киемаса (1562–1611) — выдающийся полководец"},
  {"quote": "Когда кто-то обнажает меч, он мысленно убивает человека.", "author": "Като Киемаса (1562–1611) — выдающийся полководец"},
  {"quote": "Каждый изучает то, к чему имеет естественную склонность.", "author": "Миямото Мусаси (1584–1645) — легендарный самурай"},
  {"quote": "Путь Воина есть решительное, окончательное и абсолютное принятие смерти.", "author": "Миямото Мусаси (1584–1645) — легендарный самурай"},
  {"quote": "Смерть — самое важное обстоятельство в жизни Воина. Если ты живешь, свыкнувшись с мыслью о возможной гибели и решившись на нее, если думаешь о себе как о мертвом, слившись с идеей Пути Воина, то будь уверен, что сумеешь пройти по жизни так, что любая неудача станет невозможной, и ты исполнишь свои обязанности как должно…", "author": "Миямото Мусаси (1584–1645) — легендарный самурай"},
  {"quote": "В бою состояние твоего духа не должно отличаться от повседневного. И в схватке, и в обыденной жизни ты должен быть целеустремлен, но спокоен.", "author": "Миямото Мусаси (1584–1645) — легендарный самурай"},
  {"quote": "Если каждое утро и каждый вечер ты будешь готовить себя к смерти и сможешь жить так, словно твое тело уже умерло, ты станешь подлинным самураем. Тогда вся твоя жизнь будет безупречной, и ты преуспеешь на своем поприще.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Если ты появился на свет в старинном самурайском роду, достаточно лишь глубоко задуматься над верностью предкам, презреть тело и разум и всецело посвятить себя служению хозяину. Можно считать удачей, если ты, к тому же, наделен мудростью и талантами, и умеешь правильно воспользоваться ими.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Люди полагают, что, размышляя над сложными делами, они могут разобраться с ними. Однако, когда они задумываются над чем-нибудь, у них появляются ложные мысли. Они не могут принять правильное решение, потому что в своих рассуждениях руководствуются стремлением к личной выгоде.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Всю свою жизнь прилежно учись. Каждый день становись более искусным, чем ты был за день до этого, а на следующий день — более искусным, чем сегодня. Совершенствование не имеет конца.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Правильно поступает тот, кто относится к миру, словно к сновидению. Когда тебе снится кошмар, ты просыпаешься и говоришь себе, что это был всего лишь сон.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Тот, кто знает очень мало, будет напускать на себя вид знатока. Это говорит о его неопытности. Если человек что-то хорошо знает, об этом по нему не скажешь. Такой человек ведет себя благопристойно.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Очень расчетливый ум не достоин уважения. Рассчитывать — это значит взвешивать и помнить, что можно потерять и что нужно выиграть. Расчетливый ум никогда не сможет подняться над мыслью о корысти и убытках. А что есть смерть, как не убыток? Что есть жизнь, как не корысть? Кто рассчитывает, тот корыстен. Поскольку такой человек в любых обстоятельствах работает только с корыстной целью, — он должен опасаться смерти. Значит, такой человек — трус.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Я постиг, что Путь Самурая — это смерть. В ситуации «или — или» без колебаний выбирай смерть. Это нетрудно. Исполнись решимости и действуй.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Самурай должен всегда помнить — помнить днем и ночью, с того дня, когда он берет в руки палочки, находясь в предвкушении новогодней трапезы, до последней ночи уходящего года, когда он платит оставшиеся долги, — помнить о том, что он должен умереть.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Чтобы подняться более высоко, упражняйся всегда, что бы не случилось с тобой.", "author": "Ямамото Цунэтомо (1659–1719) — самурай, автор трактата о самурайской этике «Сокрытое в листве»"},
  {"quote": "Жизнь — это мгновение за мгновением, и мера вашей жизни — то, как ваш дух расцветает в каждое из этих мгновений.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Смысл победы в отсутствии конфликта. Смысл отсутствия конфликта в отсутствии отделенности.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Никогда не знать поражения означает никогда не вступать в борьбу.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Подобно тому, как Природа любит и защищает все свои создания и помогает всему сущему расти и развиваться, так и айкидо ведет каждого, кто посвящает себя ему, по пути познания своих истин, предоставляя эту возможность со всей своей искренностью.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Айкидо — это лекарство для больного мира. В мире есть зло и беспорядок, потому что люди забыли о том, что все вещи происходят из одного источника. Возвратись к этому источнику и оставь все эгоистические мысли, пустячные желания и гнев.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Двигайся, как луч света, летай, как молния, бей, как гром, вращайся вокруг устойчивого центра.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Техники требуют четырех качеств, в которых отражается природа нашего мира. В зависимости от обстоятельств, ты должен быть: твердым, как алмаз, гибким, как ива, плавным, как течение воды, или пустым, как небо.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Когда противник идет вперед, выходи навстречу и приветствуй его. Если он хочет отойти, проводи его.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Положитесь на величие того, кто правит этим миром и смело идите вперед.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Всегда старайся быть в союзе с небом и землей; тогда будешь видеть мир в истинном свете. Самодовольство исчезнет, и ты сможешь поглощать в себя любое нападение.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Созерцай устройство этого мира, слушай слова мудрых и принимай все хорошее и доброе как свое. Опираясь на это, открой свою собственную дверь к истине. Не прогляди истину, которая прямо перед тобой. Все вокруг… должно стать твоим учителем.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Кем не владеет ничто, тот владеет всем.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Все законы неба и земли живут в тебе.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Правильная поза тела отражает правильное состояние ума.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Не веди бесполезные разговоры, познавай посредством практики.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Если ты испытываешь других, соревнуешься с ними, критикуешь их — это приводит к твоему ослаблению и поражению.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "В железной руде много шлаков, ослабляющих ее свойства; плавкой, ковкой и закалкой железо превращают в сталь, и затем придают ей форму острого, как бритва, меча. Человеческие существа развиваются в той же последовательности.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Необходимо разработать стратегию, которая использовала бы все доступные физические условия и элементы. Лучшая стратегия — это та, которая полагается на неограниченный диапазон реакций.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Если твое сердце велико, чтобы принять противников, ты можешь видеть их насквозь и избегать нападений. И тогда ты сможешь направлять их по пути, указанному тебе небом и землей.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Свободный от слабости, не обращай внимания на яростные атаки своих врагов: иди и действуй!", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Не взирай на этот мир со страхом и отвращением. Смело смотри в лицо тому, что предлагают тебе боги.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Выйди за пределы жизни и смерти, и тогда сможешь пройти через все кризисы спокойно и безопасно.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Неудача — залог успеха; каждая ошибка чему-то учит нас.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "В нашей технике мы полностью входим в атаку противника, совершенно растворяемся в ней и решительно ею управляем.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Видя меня перед собой, враг нападает, но к этому времени я уже стою за его спиной.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Твой дух есть твой истинный щит.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Побеждай своих противников духовно, заставив их осознать бессмысленность их действий. Путь Воина заключается в том, чтобы устанавливать гармонию.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "В конце концов, ты должен будешь вообще забыть о технике. Чем дальше продвигаешься, тем меньше остается догм. Великий Путь — это, на самом деле, Отсутствие Пути.", "author": "Морихэй Уэсиба (1883–1969) — основатель современного айкидо"},
  {"quote": "Азарт в игре сильнее страсти в любви.", "author": "японская пословица"},
  {"quote": "Алмазу нужна шлифовка, человеку — образование.", "author": "японская пословица"},
  {"quote": "Без предмета нет и тени.", "author": "японская пословица"},
  {"quote": "Без хорошего хода в шахматы не выиграешь.", "author": "японская пословица"},
  {"quote": "В долине вся вода в один ручей стекается.", "author": "японская пословица"},
  {"quote": "Выигрываешь — хочется выиграть еще; проигрываешь — хочется отыграться.", "author": "японская пословица"},
  {"quote": "Если хочешь убить полководца, убей сначала его коня.", "author": "японская пословица"},
  {"quote": "Есть терпение — будет и умение.", "author": "японская пословица"},
  {"quote": "Завтра будет дуть завтрашний ветер.", "author": "японская пословица"},
  {"quote": "Зеркало разума тоже тускнеет.", "author": "японская пословица"},
  {"quote": "Лунная ночь и вареный рис всегда бывают кстати.", "author": "японская пословица"},
]);

var quotes = JSON.parse(quotesFile);

//------------------------------------------------------------------------------------------------

function Vector(x, y) {
    this.x = x;
    this.y = y;
  }
  
  Vector.prototype.plus = function(other) {
    return new Vector(this.x + other.x, this.y + other.y);
  };
  
  Vector.prototype.compare = function(other) {
    if (this.x == other.x && this.y == other.y) return true;
    else return false;
  };

  Vector.prototype.multiply = function(factor) {
    return new Vector(this.x * factor, this.y * factor);
  };

  var allDirections = {
    "n":  new Vector( 0, -1),
    "ne": new Vector( 1, -1),
    "e":  new Vector( 1,  0),
    "se": new Vector( 1,  1),
    "s":  new Vector( 0,  1),
    "sw": new Vector(-1,  1),
    "w":  new Vector(-1,  0),
    "nw": new Vector(-1, -1)
  };
  
  function randomElement(array) {
    return array[Math.floor(Math.random() * array.length)];
  }

  function Game(legend) {
    //this.legend = legend;
    this.eatenActors = [];  //??
    this.actorColors = new ActorColors("white");   
    this.movesCount = 0;
    this.startTime = new Date();
    this.endTime = null;
    this.userColor = 'white';
    this.boardSize = 8;
    this.level = 'light';
    this.mode = 'classic';      
    this.endOfGame = false;
    this.currentActionDefinition = '';

    this.legend = {
      'Шашка': Checker,
      'Дамка': Dam,
    }
    
    this.chessboard = new Chessboard(this.boardSize, this.mode);
  }

  Game.prototype.updateChessboard = function() {
    //console.log('typeOf this.boardSize: ', typeof(this.boardSize), this.mode);
    this.chessboard = new Chessboard(this.boardSize, this.mode);
  }

  Game.prototype.resetGame = function() {
    this.eatenActors = [];  //??
    this.actorColors = new ActorColors("white");   
    this.movesCount = 0;
    this.startTime = new Date();
    this.endTime = null;     
    this.endOfGame = true;
    this.currentActionDefinition = '';

    this.updateChessboard();
  }

  Game.prototype.isUserTurn = function() {
    return this.userColor == this.actorColors.getCurrent();
  }

  Game.prototype.getGameTime = function() {

    this.endTime = new Date();
    var hours = (this.endTime.getHours() - this.startTime.getHours());
    var minutes = (this.endTime.getMinutes() - this.startTime.getMinutes());
    if (hours < 0) hours *= -1;
    if (minutes < 0) minutes *= -1;

    return (hours + ' ч ' + minutes + ' мин');
  }

  function ActorColors(firstColor){
    this.colors = {
        "white": false,
        "black": false,
      };	
    for (var color in this.colors) {
        if (color == firstColor) this.colors[color] = true;
    }
  };
  
  ActorColors.prototype.getCurrent = function() {
      for (var color in this.colors) {
          if (this.colors[color] == true) return color;
      }
  }
  
  ActorColors.prototype.switch = function() {
    console.log('ActorColors.prototype.switch: ');
    for (var color in this.colors) {
          this.colors[color] = !this.colors[color];
      }
    console.log('this.colors: ', this.colors);
  }

  Game.prototype.getActionDefinition = function(action, eatenActor, dam) {
    if (!action && !eatenActor && !turnToDam) return 'Game over';
      var definition = '';

      var getPositionMarks = function (position) {
        return marks.horizontal[position.x] + marks.vertical[this.chessboard.length - position.y - 1];
      }.bind(this);

      var getClassName = function(actor) {
        for (var className in this.legend) {
          var classObject = new this.legend[className]();
          console.log('classObject: ', classObject);
          if (actor instanceof this.legend[className])
            return className;
        }
      }.bind(this);
      
      if (action) {
        definition += (this.movesCount + 1) + ') ';
        definition += getClassName(action.actor);
        definition += ' цвет:' + (action.actor.color == 'white' ? 'белый' : 'черный');
        definition += ' перемещена с клетки ' + getPositionMarks(action.actor.position) + ' на клетку ' + getPositionMarks(action.vector) + '. ';
      }
      
      else if (eatenActor) {
        definition += (eatenActor.color == this.userColor) ? 'Ваша ' : 'Противника ';
        definition += getClassName(eatenActor);
        definition += ' съедена. ';
      }

      else if (dam) {
        definition += (eatenActor.color == this.user) ? 'Ваша шашка' : 'Шашка противника';
        definition += ' превратилась в дамку. ';
      }

      console.log('definition: ', definition);
      return definition;
  }

  var numTurn = 0;

  Game.prototype.turn = function(act) { 

    console.log('action: ', act);
    //console.log('typeof: ', typeof(act.actor));
    
    console.log('++++++++++++++++++++++++++++++++++++++++++++++++++++++++turn++++++++++++++++++++++++++++++++++');  
    console.log('turn # ', numTurn, 'act: ', act);
    numTurn++;              
    var action = (act == undefined) ? this.analyzeActions() : act;
    //if (act == undefined) this.IsUserTurnNow = false;
    this.currentActionDefinition = this.getActionDefinition(action);
    
    console.log('turn action: ', action, 'currentColor: ', this.actorColors.getCurrent());
    if (!action) {
      //this.endTime = new Date();
      this.endOfGame = true;
      //this.endOfGame();
    }
    else { 
      actionTypes[action.type].call(this, action);
      actionTypes.turnToDam.call(this, action);
      this.movesCount++;
      this.actorColors.switch();
      
      if (this.chessboard.whiteActorsCount == 0 || this.chessboard.blackActorsCount == 0)
        this.endOfGame = true;
    }   
  };
  
  Game.prototype.analyzeActions = function() {
    //console.log('analyzeActions');
    var possibleActions = [];   
    this.chessboard.actors.forEach(function(actor) {
      if (actor.act && actor.color == this.actorColors.getCurrent()) {
        var act = actor.act(this.chessboard); 
        //console.log('---- actor: ', actor, 'act: ', act);
        if (act) possibleActions.push({actor: actor, type: act.type, vector: act.vector, priority: act.priority});
      }
    }, this);

    var action = chooseActionFromPossible(possibleActions);
    console.log('chooseActionFromPossible: ', action, 'from possibleActions: ', possibleActions);
    return action;
  };

  var chooseActionFromPossible = function(actions) {
    if (!actions.length) return null;

    /*function maxPriority(min, cur) {
      if (cur.priority > min.priority) return cur;
      else return min;
    }

    var eatActs = actions.filter(function(data) { 
      return data.type == 'eat';
    });
    var eatAct = eatActs.length ? eatActs.reduce(maxPriority) : null;
    var moveActs = actions.filter(function(data) { 
      return data.type == 'move';
    });
    var moveAct = moveActs.length ? moveActs.reduce(maxPriority) : null;
    return eatAct || moveAct;*/

    return actions.reduce(function(min, cur) {
      if (cur.priority > min.priority) return cur;
      else return min;
    });
  }
  
  var actionTypes = Object.create(null);
  
  actionTypes.move = function(action) {
    var t = new Vector(action.actor.position.x, action.actor.position.y);
    this.chessboard.set(action.actor.position, action.vector);
    console.log('moved: ', action.actor, 'from: ', t, ' to: ', action.vector);
  };
  
  actionTypes.eat = function(action) {
    var eatenActor = this.chessboard.get(action.vector);
    this.eatenActors.push(eatenActor);
    if (eatenActor.color == "black") 
      this.chessboard.blackActorsCount --;
      
    else if (eatenActor.color == "white")
      this.chessboard.whiteActorsCount --;
    console.log('eaten: ', eatenActor, ' by: ', action.actor, 'eatenActors.length: ', this.eatenActors.length, 'whiteFiguresCount: ', this.whiteActorsCount, 'blackFiguresCount: ', this.blackActorsCount);
   
    this.chessboard.delete(eatenActor.position);  //??
    this.chessboard.set(action.actor.position, action.vector);
    this.currentActionDefinition += this.getActionDefinition(null, eatenActor);
  };

  actionTypes.turnToDam = function(action) {
    if ((action.actor.color == "white" && action.vector.y == 0) || 
      (action.actor.color == "black" && action.vector.y == (this.chessboard.length - 1))) {
        var dam = new Dam(action.actor.color, action.actor.position);
        console.log('turnToDam: ', action.actor, 'to: ', dam);
        this.chessboard.delete(action.actor.position);
        this.chessboard.add(dam);

        this.currentActionDefinition += this.getActionDefinition(null, null, dam);
      }
  }

  Checker.prototype.act = function(chessboard) {
    var view = new View(this, chessboard);
    console.log('============================================================================================');
    console.log('actor: ', this);

    var act = view.find();
    console.log('Checker.prototype.act: ', act);
    return act;
  };

  Dam.prototype.act = function(chessboard) {
    return Checker.prototype.act.call(this, chessboard);

  }
  
  function View(actor, chessboard/*, position, directions, color*/) {
    this.actor = actor;
    this.chessboard = chessboard;
   // this.position = position;
    //this.directions = directions;
    //this.color = color;
  }

  View.prototype.find = function() {
    var actions = this.findAll();
    console.log('findAll: ', actions, 'for: ', this.actor);

    var action = chooseActionFromPossible(actions);
    console.log('chooseActionFromPossible: ', action);
    return action;
  };
  
  View.prototype.look = function(vector) {  
    if (this.chessboard.isInside(vector))
      return this.chessboard.get(vector);
    else
      return null;
  };
  
  View.prototype.findAll = function() {
    var possibleDirs = [];

    var searchDirs = function(vector, dir) {
      //vector = vector.plus(allDirections[dir]);
      var look = this.look(vector);
      console.log('searchDirs for vector: ', vector, 'dir: ', dir);

      // если look не равно null, то данный вектор не выходит за пределы доски
      if (look) {
        // для простой шашки считаем по одному вектору для каждого направления
        var analyzeDir = this.analyzeMoveVector(vector);
        // если тип не равен null, значит, на клетку можно переместиться, и добавляем ее в массив возможных направлений
        if (analyzeDir.type) possibleDirs.push(analyzeDir);

        // для дамки считаем все векторы по данному направлению до тех пор, пока не встретится фигура или конец доски
        if (look.priority == 0 && (this.actor instanceof Dam))
          searchDirs(vector.plus(allDirections[dir]), dir);   // первая рекурсия
      }
    }.bind(this);

    // для каждого направления данного актера считаем вектор и для него считаем приоритет и тип (есть/двигаться/null)
    this.actor.directions.forEach(function(dir) {
      searchDirs(this.actor.position.plus(allDirections[dir]), dir);
    }.bind(this));

    return possibleDirs;
  };

  /*View.prototype.distanceToTheDamField = function(vector) {
    var dist = 0;
    if (this.actor.color == 'white') dist = vector.y;
    else if (this.actor.color == 'black') dist = this.chessboard.length - 1 - vector.y;

    console.log('distanceToTheDamField: ', this.chessboard.length/dist);
    return Math.round(this.chessboard.length / dist);
  }*/
  
  /*View.prototype.possibilityBeingEaten = function(target, otherActor) {
      var possibility = 0;
    console.log('-------------possibilityBeingEaten------------');
        
    otherActor.directions.forEach(function(dir) {
        //console.log('figure.direction: ', dir, 'vector.plus(allDirections[dir])=', vector.plus(allDirections[dir]));
          //if (target.compare(vector.plus(allDirections[dir]))) possibility++;
          if (target.compare(otherActor.position.plus(allDirections[dir]))) possibility++;
      });
    console.log('possibility: ', possibility, '--------------');
      return possibility;
  };*/
  
  /*View.prototype.possibilityToEat = function(direction) {
      var possibility = 0;
        this.directions.forEach(function(dir) {
          if (dir == direction) possibility++;
      });
      return possibility;
  };*/

  View.prototype.analyzeMoveVector = function(target) {
    //console.log('analyzeMoveVector: ', target, 'for: ', this.actor);
    var type = null;
    var priority = 0;

    // расстояние до дамочного поля. Приоритет добраться до дамочного поля тем ниже, чем больше количество дамок своего цвета
    var distanceToTheDamField = function(actor, vector) {
      // если этот актер - дамка, то расстояние не считаем
      if (actor instanceof Dam) return 0;
      else {
        var dist = 0;
        // для белых шашек расстояние до верха доски с y=0
        if (actor.color == 'white') {
          dist = (vector !== undefined) ? vector.y : actor.position.y;
          if (dist == 0) return 5;
        }
        // для черных шашек расстояние до низа доски с y=this.chessboard.length - 1
        else if (actor.color == 'black') {
          dist = (vector !== undefined) ? (this.chessboard.length - 1 - vector.y) : (this.chessboard.length - 1 - actor.position.y);
          if (dist == this.chessboard.length - 1) return 5;
        }   
        

        // количество дамок на доске своего цвета
        var alreadyDams = this.chessboard.actors.filter(function(act) {
          return (act instanceof Dam) && (act.color == actor.color);
        });
        console.log('alreadyDams: ', alreadyDams);

        //console.log('distanceToTheDamField: ', Math.round(0.5*((this.chessboard.length - 1)/ dist - alreadyDams.length)), 'for actor: ', actor, ' vector: ', vector);
        //return Math.round(0.5*((this.chessboard.length - 1)/ dist - alreadyDams.length));

        console.log('distanceToTheDamField: ', 0.5*((this.chessboard.length - 1)/ dist - alreadyDams.length), 'for actor: ', actor, ' vector: ', vector);
        return 0.5*((this.chessboard.length - 1)/ dist - alreadyDams.length);
      }      
    }.bind(this);

    // найти все направления актера к заданному вектору
    var findActorsDirsToVector = function(actor, vector, dirToVector) {
      var dirs = [];

      actor.directions.forEach(function(dir) {
        if (dirToVector !== undefined && dirToVector == dir)
          dirs.push(dir);
        else if (vector.compare(actor.position.plus(allDirections[dir]))) {
          dirs.push(dir);
        }
      }); 

      console.log('findActorsDirsToVector: ', dirs, 'for element: ', actor, 'for vector: ', vector);
      return dirs;
    }

    var calcTypeForVector = function(element, isActorDir) {
      var type = null;

      // если это направление одно из направлений актера
      if (isActorDir) {
        // если клетка пустая , то тип "двигаться"
        if (element && element.priority == 0) {   
          type = "move";
        }

        // если на клетке фигура другого цвета, то тип "есть"
        else if (element && element.priority > 0 && element.color !== this.actor.color) {
          type = "eat";
        }
      }
      console.log('calcTypeForVector: ', type, 'element: ', element, 'isActorDir: ', isActorDir);
      return type;
    }.bind(this);

    var calcPriorityForVector = function(vectorIsTarget, vector, element, isActorDir) {
      var priority = 0;
      
      // если на клетке фигура своего цвета, и мы считаем для промежуточного вектора
      // то если на конечном векторе target съедят актера, она может съесть съевшую фигуру, поэтому добавляем приоритет
      if (element && element.priority > 0 && element.color == this.actor.color && !vectorIsTarget) {
        var elementDirs = findActorsDirsToVector(element, vector);  //??

        // если эта фигура вообще может перейти на эту клетку
        if (elementDirs.length)
          //vectorPriority += this.actor.priority * 2;  //??
          priority += this.actor.priority;
      }

      // если на клетке фигура другого цвета
      else if (element && element.priority > 0 && element.color !== this.actor.color) {
        
        // если считаем для конечного вектора, или дял промежуточного и это направление актера, то ее можно съесть
        // и надо посчитать приоритет съедания данной фигуры
        console.log('vectorIsTarget: ', vectorIsTarget, 'isActorDir: ', isActorDir);
        if (vectorIsTarget || (!vectorIsTarget && isActorDir)) {

          // считаем расстояние до дамочного поля для фигуры, которую собираемся съесть - чем она ближе к полю, тем приоритетнее ее съесть
          priority += 0.5 * distanceToTheDamField(element); //??

          // если считаем для конечного вектора, то надо учесть, что если мы ее не съедим, то на следующем ходе она может съесть нас
          // поэтому к приоритету сразу добавляем приоритет самого актера
          if (vectorIsTarget) {
            priority += this.actor.priority;   //??

            if (this.actor instanceof Dam) {
              priority += 3 * element.priority;  //дамкой есть приоритетнее, потому что это дамка (?)
            }
            else { 
              priority += element.priority;
            }
          }

          // если считаем для промежуточного вектора, то фигура может нас съесть сама
          // считаем вероятность быть съеденным этой фигурой (минусовой приоритет)
          if (!vectorIsTarget){
            var elementDirs = findActorsDirsToVector(element, vector);  //??

            // если у фигуры есть направления к рассматриваемому вектору
            if (elementDirs.length)
              //vectorPriority -= (this.actor instanceof Dam) ? 3*this.actor.priority : 2*this.actor.priority;
              priority -=  2 * this.actor.priority;   // ??
          } 
        }      
      }
      console.log('calcPriorityForVector: ', priority, 'vector: ', vector);
      return priority;
    }.bind(this);

    // vectorIsTarget - этот флаг обозначает, считаем ли мы приоритет для вектора конечной цели (target), или для промежуточных векторов (находящихся вокруг вектора target)
    // если считаем для промежуточного, то будут заданы dirToVector и target, если нет, то они будут undefined
    var calcVectorData = function(vectorIsTarget, vector, dirToVector, target) {
      var type = null;  
      var priority = 0;
      var element = this.look(vector);
      console.log('--- look element: ', element);

      // если element=null, то это клетка вне поля
      if (!element) return {type: type, priority: priority};

      // является ли напраление к вектору одним из направлений актера
      var isActorDir = false;
      // если считаем для конечного вектора
      if (vectorIsTarget) isActorDir = true;
      // или если среди направлений актера есть dirToVector, то является
      else if (dirToVector !== undefined) {
        var actorDirs = findActorsDirsToVector(this.actor, vector, dirToVector);
        if (actorDirs.length) 
          isActorDir = true;
      }      

      type = calcTypeForVector(element, isActorDir);
      priority += calcPriorityForVector(vectorIsTarget, (target !== undefined ? target : vector), element, isActorDir);

      // если считаем для конечного вектора, то к приоритету добавляется расстояние до дамочного поля от конечного вектора target
      if (vectorIsTarget)
        priority += distanceToTheDamField(this.actor, target);

      return {type: type, priority: priority};
    }.bind(this);

    /*var calcAllVectorsData = function(vector) {
      var priority = 0;
      var recursionDepth = 0;
      
      function analyzeAllDirections(vector) {
        for (var directionFromVector in allDirections) {
          var intermediateVector = vector.plus(allDirections[directionFromVector]);
          // если это не текущее положение актера
          if (!this.actor.position.compare(intermediateVector)) {  
            // то считаем для каждого вектора вокруг заданного вектора  
            console.log('~~~~~~~~~~');   
            console.log('recursion ', recursionDepth);     
            var dirData = calcVectorData(false, intermediateVector, directionFromVector, vector);  
            //priority += dirData.priority / 2;
            priority += dirData.priority;
            console.log('call calcMovePriority: ', dirData, 'for vector: ', intermediateVector, 'form target: ', vector);
          
            if (dirData.type) {
              analyzeAllDirections(intermediateVector);
              recursionDepth ++;
            }
          }
        }
      }
      
      return priority;
    }*/

    var targetData = calcVectorData(true, target);
    console.log('calcMovePriority: ', targetData, 'for vector: ', target);
    type = targetData.type;
    priority += targetData.priority;

    // если есть тип - "есть"/"двигаться", значит, на клетку можно переместиться
    // и значит, имеет смысл посчитать приоритет для окружающих ее клеток
    if (type) {
      for (var directionFromTarget in allDirections) {
          var vector = target.plus(allDirections[directionFromTarget]);
          // если это не текущее положение актера
          if (!this.actor.position.compare(vector)) {  
            // то считаем для каждого вектора вокруг конечного вектора  
            console.log('~~~~~~~~~~');        
            var dirData = calcVectorData(false, vector, directionFromTarget, target);  
            //priority += dirData.priority / 2;
            priority += dirData.priority;
            console.log('call calcMovePriority: ', dirData, 'for vector: ', vector, 'form target: ', target);

            /*if (dirData.type) {
              for (var directionFromVector in allDirections) {
                console.log('~~~'); 
                var intermediateVector = vector.plus(allDirections[directionFromVector]);
                var intermediateDirData = calcVectorData(false, intermediateVector, directionFromVector, vector);  
                priority += intermediateDirData.priority;
                console.log('call intermediate calcMovePriority: ', intermediateDirData, 'for vector: ', intermediateVector, 'form target: ', vector);
              }
            }*/
          }
      }
    }    
        
  console.log('&&&&&&& analyzeMoveVector: ', target, 'for: ', this.actor);
  console.log('&&&&&&&&&&&&& type: ', type, 'sum priority: ', priority);
    return {vector: target, type: type, priority: priority};
};
  
  /*View.prototype.analyzeMoveVector = function(target) {
      //console.log('analyzeMoveVector: ', target, 'for: ', this.actor);
      var type = null;
      var priority = 0;

      // расстояние до дамочного поля. Приоритет добраться до дамочного поля тем ниже, чем больше количество дамок
      var distanceToTheDamField = function(actor, vector) {
        // если этот актер - дамка, то расстояние не считаем
        if (actor instanceof Dam) return 0;
        else {
          var dist = 0;
          // для белых шашек расстояние до верха доски с y=0
          if (actor.color == 'white') {
            dist = (vector !== undefined) ? vector.y : actor.position.y;
          }
          // для черных шашек расстояние до низа доски с y=this.chessboard.length - 1
          else if (actor.color == 'black') {
            dist = (vector !== undefined) ? (this.chessboard.length - 1 - vector.y) : (this.chessboard.length - 1 - actor.position.y);
          }   
          //console.log('distanceToTheDamField: ', this.chessboard.length/dist);
          // return Math.round(this.chessboard.length / dist);

          // количество дамок на доске своего цвета
          var alreadyDams = this.chessboard.actors.filter(function(act) {
            return (act instanceof Dam) && (act.color == actor.color);
          });
          console.log('alreadyDams: ', alreadyDams);

          console.log('distanceToTheDamField: ', Math.round(0.5*((this.chessboard.length - 1)/ dist - alreadyDams.length)), 'for actor: ', actor, ' vector: ', vector);
          return Math.round(0.5*((this.chessboard.length - 1)/ dist - alreadyDams.length));
        }      
      }.bind(this);

      var findActorsDirsToVector = function(actor, vector) {
        var dirs = [];

        actor.directions.forEach(function(dir) {
          if (vector.compare(actor.position.plus(allDirections[dir]))) {
            dirs.push(dir);
          }
        }); 

        return dirs;
      }

      var calcMovePriority = function(isCalcForTarget, isCalcForCurrent, vector, dirToVector, target) {
        var type = null;  //type остается равным null для тех направлений, где фигуры своего цвета
        var vectorPriority = 0;
        var element = this.look(vector);

        console.log('--- look element: ', element);

        // если element=null, то это клетка вне поля, можно для нее ничего не считать
        if (!element) return {type: type, priority: vectorPriority};

        // является ли напраление к вектору одним из направлений актера
        var isActorDir = false;
        // если мы считаем для конечного вектора или среди направлений актера есть dirToVector
        if (isCalcForTarget || (dirToVector !== undefined &&   //??
          this.actor.directions.filter(function(dir) {
            return dir == dirToVector;
          }).length)) {
            isActorDir = true;
          }

        // если клетка пустая и это направление одно из направлений актера, то тип "двигаться"
        if (element && element.priority == 0 && isActorDir) {   //??
            type = "move";
            // здесь тоже как-то приорити добавлять!
        }

        // если на клетке фигура своего цвета, и мы считаем для промежуточного вектора
        // то если на конечном векторе target съедят актера, она может съесть съевшую фигуру, поэтому добавляем приоритет
        else if (element && element.priority > 0 && element.color == this.actor.color && !isCalcForTarget) {
          var elementDirs = findActorsDirsToVector(element, target);  //??
          console.log('findActorsDirsToVector: ', elementDirs, 'for element: ', element, 'for vector: ', target);

          // если эта фигура вообще может перейти на эту клетку
          if (elementDirs.length)
            //vectorPriority += this.actor.priority * 2;  //??
            vectorPriority += this.actor.priority;
        }

        // если на клетке фигура другого цвета
        else if (element && element.priority > 0 && element.color !== this.actor.color) {
          // isCalcForTarget - этот флаг обозначает, считаем ли мы приоритет для вектора конечной цели (target), или для промежуточных векторов (находящихся вокруг вектора target)
          // если считаем для конечного вектора, или дял промежуточного и это направление актера, то тип "есть"
          // и надо посчитать приоритет съедания данной фигуры
          if (isCalcForTarget || (!isCalcForTarget && !isCalcForCurrent && isActorDir)) {
            type = "eat";
            // считаем расстояние до дамочного поля для фигуры, которую собираемся съесть - чем она ближе к полю, тем приоритетнее ее съесть
            vectorPriority += 0.5 * distanceToTheDamField(element); //??

            if (this.actor instanceof Dam) {
              vectorPriority += 3 * element.priority;  //дамкой есть приоритетнее, потому что это дамка (?)
            }
            else { 
              vectorPriority += element.priority;
            }

            // если считаем для промежуточного вектора, то фигура может нас съесть сама
            // считаем вероятность быть съеденным этой фигурой (минусовой приоритет)
            if (!isCalcForTarget){
              var elementDirs = findActorsDirsToVector(element, target);  //??
              console.log('findActorsDirsToVector: ', elementDirs, 'for element: ', element, 'for vector: ', target);

              // если у фигуры есть направления к рассматриваемому вектору
              // то считаем вероятность быть съеденным
              if (elementDirs.length)
                //vectorPriority -= (this.actor instanceof Dam) ? 3*this.actor.priority : 2*this.actor.priority;
                vectorPriority -= 2*this.actor.priority;
            } 
          }      
        }
        return {type: type, priority: vectorPriority};
      }.bind(this);

      //priority += distanceToTheDamField(this.actor, target);

      var data = calcMovePriority(true, false, target);
      console.log('calcMovePriority: ', data, 'for vector: ', target);
      type = data.type;
      priority += data.priority;

      // если есть тип - "есть"/"двигаться", значит, на клетку можно переместиться
      // и значит, имеет смысл посчитать ее расстояние до дамочного поля и приоритет для окружающих ее клеток
      if (type) {
        priority += distanceToTheDamField(this.actor, target);

        for (var directionFromTarget in allDirections) {
            var vector = target.plus(allDirections[directionFromTarget]);
            // если это не текущее положение актера
            if (!this.actor.position.compare(vector)) {  
              // то считаем для каждого вектора вокруг конечного вектора          
              var dirData = calcMovePriority(false, false, vector, directionFromTarget, target);  //??
              //priority += dirData.priority / 2;
              priority += dirData.priority;
              console.log('call calcMovePriority: ', dirData, 'for vector: ', vector, 'form target: ', target);
            }
        }
      }     
          
    console.log('&&&&&&& analyzeMoveVector: ', target, 'for: ', this.actor);
    console.log('&&&&&&&&&&&&& type: ', type, 'sum priority: ', priority, 'Math.round(priority): ', Math.round(priority));
      return {vector: target, type: type, priority: priority};
  };*/
  
  

  //----------------------------------------------------------------------

function Cell(color) {
    this.priority = 0;
    this.color = color;
}

function Checker(color, position) {
	this.priority = 1;
  this.color = color;
  this.position = position;
  //this.size = 0.8;
  this.directions = (color == "white") ? ["ne", "nw"] : ["se", "sw"];
  //this.modified = true;
  //this.deleted = false;
}

function Dam(color, position) {
	Checker.call(this, color, position);
  this.priority = 5;
  this.directions = ["n", "e", "s", "w"];
}


var legend = {};
legend[new Checker()] = 'Шашка';
legend[new Dam()] = 'Дамка';

function Chessboard(length, mode) {
    this.length = length;
    this.mode = mode;
    this.grid = [];
    this.actors = [];
    this.whiteActorsCount = 0;
    this.blackActorsCount = 0; 

    var fillGrid = function() {
        for (var y = 0; y < this.length; y++) {
            var row = [];
            for (var x = 0; x < this.length; x++) {
                var color = (y + x) % 2 == 0 ? 'white' : 'black';
                row[x] = new Cell(color);
            }
            this.grid.push(row);
        } 
    }.bind(this);

    var fillActors = function(color) {
        //if (this.mode == 'classic') {
            var firstNum, secondNum;
            if (color == 'black') {
                firstNum = 0;
                secondNum = this.length/2 - 1;
            }
            else if (color == 'white') {
                firstNum = this.length/2 + 1;
                secondNum = this.length;
            }
            for (var y = firstNum; y < secondNum; y++) {
                var row = [];
                for (var x = 0; x < this.length; x++) {
                    if ((y + x) % 2 !== 0) {
                      if (this.mode == 'classic')
                        this.actors.push(new Checker(color, new Vector(x,y)));
                      else if (this.mode == 'dam')
                        this.actors.push(new Dam(color, new Vector(x,y)));

                      if (color == 'black') this.blackActorsCount++;
                      else this.whiteActorsCount++;
                    }                        
                }
            } 
        //}
    }.bind(this);

    fillGrid();
    fillActors('black');
    fillActors('white');
    //console.log(this.actors);
  }
  
  Chessboard.prototype.isInside = function(vector) {
    return vector.x >= 0 && vector.x < this.length && vector.y >= 0 && vector.y < this.length;
  };

  Chessboard.prototype.find = function(pos) {
    var actor = this.actors.filter(function(actor) {  
      return actor.position.compare(pos) == true;
    });
    if (actor.length) return actor[0];
    else return null;
  }

  Chessboard.prototype.get = function(pos) {
    var actor = this.find(pos);  
    return actor || this.grid[pos.y][pos.x];
  };

  Chessboard.prototype.set = function(pos, dest) {
    this.actors.filter(function(actor) {  
      if (actor.position.compare(pos) == true)
        actor.position = dest;
    });
  };

  Chessboard.prototype.add = function(actor) {
    this.actors.push(actor);
  }

  Chessboard.prototype.delete = function(pos) { 
    var actor = this.find(pos);
    if (actor) {
      var index = this.actors.indexOf(actor);
      this.actors = this.actors.slice(0, index).concat(this.actors.slice(index + 1));
    }
  };

  /*Chessboard.prototype.setActorModified = function(pos, isModified) {
    var actor = this.get(pos);
    actor.modified = isModified;
  }*/

//---------------------------------

function DOMDisplay(parent, game) {
    this.game = game;
    this.wrap = null;
    this.quotebar = null;
    this.innerWrap = null;
    this.panel = null;
    this.board = null; //??
    //this.actorLayer = null;
    this.toolbar = null; //??
    this.infobar = null; //??
    this.tablo = null;

    this.wrap = document.createElement('div');   //app
    this.wrap.className = 'wrap';
    parent.appendChild(this.wrap);

    this.quotebar = this.drawQuotebar();    //header
    this.wrap.appendChild(this.quotebar);

    this.innerWrap = document.createElement('div');   //main
    this.innerWrap.className = 'inner-wrap';
    //parent.appendChild(this.innerWrap);
    this.wrap.appendChild(this.innerWrap);


    this.toolbar = this.innerWrap.appendChild(this.drawToolbar());
    this.panel = this.innerWrap.appendChild(this.drawPanel());
    //this.toolbar.style.height = this.panel.style.width;   //??
    this.board = this.panel.appendChild(this.drawBoard());
    //this.actorLayer = this.board.appendChild(this.drawActors());
    this.infobar = this.innerWrap.appendChild(this.drawInfobar());
}

DOMDisplay.prototype.drawTool = function(note, type, attributes) {
  var toolNode = null;
  var node = null;

  if (note) {
    toolNode = document.createElement('div');
    toolNode.appendChild(document.createTextNode(note));
  } 

  if (type) {
    node = document.createElement(type);
    if (attributes) {
      for (var attr in attributes)
        if (attributes.hasOwnProperty(attr))
          node.setAttribute(attr, attributes[attr]);
    }
    for (var i = 3; i < arguments.length; i++) {
      var child = arguments[i];
      var childNode = null;
      if (typeof child == "string")
        childNode = document.createTextNode(child);
      else 
        childNode = child;
      node.appendChild(childNode);
    }
  }

  if (!toolNode) return node;
  else {
    if (node) toolNode.appendChild(node);
    return toolNode; 
  }
}

DOMDisplay.prototype.drawQuotebar = function() {
  var quotebar = document.createElement('div');
  quotebar.className = 'quotebar';

  var updateQuote = function() {
    var newQuote = randomElement(quotes);
    quoteText.textContent = '"' + newQuote.quote + '"';
    authorText.textContent = newQuote.author;
  }

  var quoteText = quotebar.appendChild(this.drawTool(null, 'p', {class: 'quoteText'}));
  var authorText = quotebar.appendChild(this.drawTool(null, 'p', {class: 'authorText'}));
  updateQuote();
  
  setInterval(updateQuote, 60000);
  
  return quotebar;
}

DOMDisplay.prototype.drawToolbar = function() {
  var toolbar = document.createElement('div');
  toolbar.className = 'bar';

  var form = toolbar.appendChild(document.createElement('form'));

  var whiteOption = this.drawTool(null, 'option', {value: 'white'}, 'белые');
  var blackOption = this.drawTool(null, 'option', {value: 'black'}, 'черные');
  form.appendChild(this.drawTool( 'Выберите цвет ваших фигур: ', 'select', {name: 'userColor'}, whiteOption, blackOption));

  var sizeTool = form.appendChild(this.drawTool('Выберите размер доски: ', 'input', {name: 'boardSize', type: 'number', value: 8, min: 2, max: 14, step: 2}));

  var easyOption = this.drawTool(null, 'option', {value: 'easy'}, 'легкий');
  var mediumOption = this.drawTool(null, 'option', {value: 'medium'}, 'средний');
  var hardOption = this.drawTool(null, 'option', {value: 'hard'}, 'сложный');
  form.appendChild(this.drawTool('Выберите уровень сложности: ', 'select', {name: 'level'}, easyOption, mediumOption, hardOption));

  var classicOption = this.drawTool(null, 'option', {value: 'classic'}, 'классический');
  var damOption = this.drawTool(null, 'option', {value: 'dam'}, 'играть только дамками');
  var modeTool = form.appendChild(this.drawTool('Выберите режим игры: ', 'select', {name: 'mode'}, classicOption, damOption));

  form.appendChild(this.drawTool(null, 'button', {type: 'submit'}, 'Начать игру'));

  var changeListener = function(event) {
    //event.target.disabled = true;
    console.log('ddddddddddddd', this);
    this.game[event.target.name] = event.target.value;
    this.game.updateChessboard();
    this.updateBoard();
    //event.target.disabled = false;
  }.bind(this);

  sizeTool.addEventListener('change', changeListener);
  modeTool.addEventListener('change', changeListener);

  var submitListener = function(event) {
    event.preventDefault();

    for (var i = 0; i < form.elements.length; i++) {
      form.elements[i].disabled = true;
      form.elements[i].style.cursor = 'default';

      if (form.elements[i].name) {
        console.log(form.elements[i].name, form.elements[i].value);
        this.game[form.elements[i].name] = form.elements[i].value;
      }
    }
    this.drawUserFunctionality();
  }.bind(this);

  form.addEventListener('submit', submitListener);

  return toolbar;
}

DOMDisplay.prototype.drawInfobar = function() {
  var infobar = document.createElement('div');
  infobar.className = 'bar';

  infobar.appendChild(this.drawTool('Сейчас ход: ', 'span', {class: 'turn'}, (this.game.isUserTurn() ? 'ваш' : 'компьютера')));
  infobar.appendChild(this.drawTool('Прошло времени: ', 'p', {class: 'time'}, String(this.game.getGameTime())));
  infobar.appendChild(this.drawTool('Сделано ходов: ', 'span', {class: 'moves-count'}, String(this.game.movesCount)));  
  infobar.appendChild(this.drawTool('Белые фигуры на доске: ', 'span', {class: 'white-actors'}, String(this.game.chessboard.whiteActorsCount))); 
  infobar.appendChild(this.drawTool('Черные фигуры на доске: ', 'span', {class: 'black-actors'}, String(this.game.chessboard.blackActorsCount)));  
  infobar.appendChild(this.drawTool('История ходов: ', 'textarea', {class: 'moves-history'}), 'Game start');

  setInterval(function() {
    infobar.querySelector('.time').textContent = String(this.game.getGameTime());
  }, 60000);

  return infobar;
}

DOMDisplay.prototype.resetDisplay = function() {
  function getDefaultClassName(element) {
    var index = element.className.indexOf(' game-over');
    console.log(element.className.slice(0, index));
    return index !== -1 ? element.className.slice(0, index) : element.className;
  }

  console.log(this.panel.className);
  this.panel.className = getDefaultClassName(this.panel);
  console.log(this.panel.className);
  this.toolbar.className = getDefaultClassName(this.toolbar);
  this.infobar.className = getDefaultClassName(this.infobar);

  if (this.tablo)
    this.innerWrap.removeChild(this.tablo);

  var form = this.toolbar.querySelector('form'); //??
  for (var i = 0; i < form.elements.length; i++) {
    form.elements[i].disabled = false;
    form.elements[i].style.cursor = 'pointer';
  }

  this.infobar.querySelector('.moves-history').textContent = 'Game start';
  this.game.resetGame();
  this.updateDisplay();
}

DOMDisplay.prototype.updateBoard = function() {
  if (this.board)
    this.panel.removeChild(this.board);  
  this.board = this.panel.appendChild(this.drawBoard());
}

DOMDisplay.prototype.updateDisplay = function() {

  this.updateBoard();
  
  //добавить данные в инфобар
  this.infobar.querySelector('.turn').textContent = (this.game.isUserTurn() ? 'ваш' : 'компьютера');
  this.infobar.querySelector('.moves-count').textContent = this.game.movesCount;
  this.infobar.querySelector('.white-actors').textContent = this.game.chessboard.whiteActorsCount;
  this.infobar.querySelector('.black-actors').textContent = this.game.chessboard.blackActorsCount;

  var textarea = this.infobar.querySelector('.moves-history');
  textarea.textContent += this.game.currentActionDefinition + '\n' + '\n';
  textarea.scrollTop = textarea.scrollHeight;
  
};

DOMDisplay.prototype.drawGameOver = function() {
  this.panel.className += ' game-over';
  this.toolbar.className += ' game-over';
  this.infobar.className += ' game-over';

  var tablo = document.createElement('div');
  tablo.className = 'tablo';
  
  tablo.appendChild(this.drawTool('GAME OVER'));
  var isUserWin = this.game.userColor == 'white' ? (this.game.chessboard.whiteActorsCount !== 0 ? true : false) : (this.game.chessboard.blackActorsCount !== 0 ? true : false);
  tablo.appendChild(this.drawTool((isUserWin ? 'Вы выиграли!' : 'Вы проиграли!')));
  var score = this.game.userColor == 'white' ? (this.game.chessboard.whiteActorsCount + ' : ' + this.game.chessboard.blackActorsCount) : (this.game.chessboard.blackActorsCount + ' : ' + this.game.chessboard.whiteActorsCount);
  tablo.appendChild(this.drawTool('Со счетом ' + score));
  tablo.appendChild(this.drawTool('Количество ходов: ' + this.game.movesCount));
  tablo.appendChild(this.drawTool('Прошло времени: ' + this.game.getGameTime()));
  this.tablo = this.innerWrap.appendChild(tablo);

  var reset = function(event) {
      event.preventDefault();
      this.resetDisplay();
      removeEventListener('click', reset);
      removeEventListener('keydown', reset);
  }.bind(this);

  addEventListener('click', reset);
  addEventListener('keydown', reset); 
}

var marks = {
  horizontal : ['A', 'B', 'C', 'D', 'E', 'F', 'G', 'H', 'I', 'J'],
  vertical: ['1', '2', '3', '4', '5', '6', '7', '8', '9', '10'],
};

DOMDisplay.prototype.drawPanel = function() {

  var panel = document.createElement('main');

  var drawMarks = function(marksMass, position) {
      for (var i = 0; i < this.game.chessboard.length; i++) {
          var mark = document.createElement("span");
          mark.className = 'mark';
          mark.textContent = marksMass[i];

          mark.className += ' ' + position;
          if (position == 'horizontal') {
            mark.style.left = (9.5 * (i+1) - 1) + 'vmin';   //??
          }
          else if (position == 'vertical') {
            mark.style.top = (9.5 * (this.game.chessboard.length - i) - 1.5) + 'vmin';   //??
          }
    
          panel.appendChild(mark);
      }
  }.bind(this);

    drawMarks(marks.horizontal, 'horizontal');
    drawMarks(marks.vertical, 'vertical');      
    return panel;
}

/*DOMDisplay.prototype.drawBoard = function() {
  var board = document.createElement('table');
  board.className = 'board';        
  var y = 0;
  this.game.chessboard.grid.forEach(function(row) {
    var x = 0;
    var rowElt = document.createElement("tr");
    board.appendChild(rowElt);
    //rowElt.style.height = scale + "px";
    row.forEach(function(elt) {
        var cell = document.createElement('td');
        //cell.style.width = scale + "px";
        cell.className = 'cell ' + elt.color;
        cell.position = {
          x: x,
          y: y,
        }  
        rowElt.appendChild(cell);
        x++;
    });
    y++;
  });

  return board;
}*/

DOMDisplay.prototype.drawBoard = function() {
  var board = document.createElement('table');
  board.className = 'board';        
  var y = 0;
  this.game.chessboard.grid.forEach(function(row) {
    var x = 0;
    var rowElt = document.createElement("tr");
    board.appendChild(rowElt);
    //rowElt.style.height = scale + "px";
    row.forEach(function(elt) {
        var cell = document.createElement('td');
        //cell.style.width = scale + "px";
        cell.className = 'cell ' + elt.color;
        cell.position = {
          x: x,
          y: y,
        }; 
        
        var actorAtCell = this.game.chessboard.actors.filter(function(actor) {
          return (actor.position.x == cell.position.x && actor.position.y == cell.position.y);
        });
        if (actorAtCell.length) {
          var elt = document.createElement('div');
          elt.className = 'actor ' + actorAtCell[0].color;
          elt.actor = actorAtCell[0];
          if (actorAtCell[0] instanceof Checker) elt.className += ' сhecker';
          else if (actorAtCell[0] instanceof Dam) elt.className += ' dam';

          cell.appendChild(elt);
        }

        rowElt.appendChild(cell);
        x++;
    }.bind(this));
    y++;
  }.bind(this));

  return board;
}

DOMDisplay.prototype.drawActors = function() {   
  var wrap = document.createElement('div');

  this.game.chessboard.actors.forEach(function(actor) {
    var elt = document.createElement('div')
    elt.className = 'actor ' + actor.color;
    elt.actor = actor;
    if (actor instanceof Checker) elt.className += ' сhecker';
    else if (actor instanceof Dam) elt.className += ' dam';
  
    elt.style.left = (actor.position.x * 9.5) + "vmin";  //??
    elt.style.top = (actor.position.y * 9) + "vmin";   //??
    

    wrap.appendChild(elt);
  });

  return wrap;
};

DOMDisplay.prototype.drawUserFunctionality = function() {
  var cells = Array.prototype.slice.call(this.board.getElementsByClassName('cell'), 0);
  var actorElts = Array.prototype.slice.call(this.board.getElementsByClassName('actor'), 0);
  //console.log(actorElts);

  function select(event) {
    //console.log('!!!-----select: ', event);
    var elt = event.target;

    if (elt.dirs.length) elt.style.cursor = 'pointer';    
    elt.style.borderColor = 'orange';
    //console.log('event! ', dirCells);
    elt.dirs.forEach(function(dir) {
      //console.log(dir.cell.position);
      dir.cell.style.background = 'orange';
    });
  }

  function deselect(event) {
    console.log('!!!-----deselect: ', event);
    var elt = event.target;
    elt.style.borderColor = '';
    //console.log('event! ', dirCells);
    elt.dirs.forEach(function(dir) {
      dir.cell.style.background = '';
    });
  }

  function move(event) {  
    
    console.log('!!!-----move: ', event);
    var elt = event.target;

    console.log('!!!-----mousedown: ', elt.actor, elt.dirs);

    actorElts.forEach(function(actorElt) {
      if (actorElt.actor.position.x == elt.actor.position.x && actorElt.actor.position.y == elt.actor.position.y) return;

      actorElt.style.cursor = 'default';

      actorElt.removeEventListener("mouseover", select);
      actorElt.removeEventListener("mouseout", deselect);
      actorElt.removeEventListener('mousedown', move);
    });

    elt.removeEventListener("mouseout", deselect);
    //addEventListener("mouseup", deselect); 

    console.log("dirs: ", elt.dirs, 'actor: ', elt.actor);
    elt.dirs.forEach(function(dir) {

      function turn(event) {
        console.log('!!!-----mouseup: ', elt.actor, dir, dir.cell.position);
        
        //deselect();
        console.log('!!!-----turn: ', elt.actor, elt.dirs);
        //console.log('mouseup dir: ', dir.cell.position, dir.type);  
        console.log('game turn: ', 'actor: ', elt.actor, 'type: ', dir.type, 'vector: ', new Vector(dir.cell.position.x, dir.cell.position.y));       
        game.turn({actor: elt.actor, type: dir.type, vector: new Vector(dir.cell.position.x, dir.cell.position.y)});  //??
        //display.drawTurn();
        display.animate();
      }

      if (!dir.actorAtCell) {
        dir.cell.addEventListener('mouseup', turn);
        console.log('dir.cell.addEventListener: ', dir.cell, dir.cell.position);
      }
      else {
        dir.actorAtCell.addEventListener('mouseup', turn);
        console.log('dir.actorAtCell.addEventListener: ', dir.cell, dir.cell.position);
      }
    });
  }

  actorElts.forEach(function(elt) {
    if (elt.actor.color !== this.game.userColor) return;
    elt.dirs = []; 

    var searchDirs = function(vector, dir) {
      var type = null;
      //var vector = elt.actor.position.plus(allDirections[dir]);
      var dirCell = cells.filter(function(cell) {
        return (cell.position.y == vector.y && cell.position.x == vector.x)  
      });

      if (dirCell.length) {
        var actorAtCell = actorElts.filter(function(actorElt) {
          return (actorElt.actor.position.y == vector.y && actorElt.actor.position.x == vector.x);
        })
        //var color = actorAtCell.length ? actorAtCell[0].color : null;
        //console.log('actorAtCell: ', actorAtCell, vector, 'actorAtCell[0].color: ', color, 'elt.actor.color: ', elt.actor.color);
        if (!actorAtCell.length) {
          type = 'move';
          elt.dirs.push({cell: dirCell[0], type: type, actorAtCell: null});

          if (elt.actor instanceof Dam)
            searchDirs(vector.plus(allDirections[dir]), dir);   // вторая рекурсия
        }
        else if (actorAtCell.length && actorAtCell[0].actor.color !== elt.actor.color) {
          type = 'eat';
          elt.dirs.push({cell: dirCell[0], type: type, actorAtCell: actorAtCell[0]});
        }
      }
    }

    elt.actor.directions.forEach(function(dir) {
      var vector = elt.actor.position.plus(allDirections[dir]);
      searchDirs(vector, dir);
    });

    elt.addEventListener("mouseover", select);
    elt.addEventListener("mouseout", deselect); 

    if (elt.dirs.length) elt.addEventListener('mousedown', move);
  });      
}

//const DOMDisplay = require('DOMDisplay');  //???
var app = document.querySelector('.app');
//var chessboard = new Chessboard(8, 'classic');
var game = new Game(legend);
var display = new DOMDisplay(app, game);

//display.drawUserFunctionality();

DOMDisplay.prototype.animate = function() {
  display.updateDisplay();

  setTimeout(function() {
    game.turn();
    display.updateDisplay();

    if (game.endOfGame) { 
      // тоже переделать  
      display.drawGameOver();
    }
    else
      display.drawUserFunctionality();
  }, 1000);
} 

/*addEventListener("keydown", function(event) {
  if (event.keyCode == 38 && !game.end) {
    game.turn();
    display.drawTurn();
    display.drawUserFunctionality(currentColor);
    console.log('main addEventListener');
  }
});*/





